#include<GL/glut.h>

#define TOP 1
#define BOTTOM 0

extern GLint XMAX;
extern GLint YMAX;
extern GLfloat colors[][3];
extern GLint clr;
extern GLint padding;

int numberOfPatternColumns = 2;
int currentPattern = 1;

GLubyte patterns[][128] = {
	{
	0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33,
	0x00, 0x00, 0x00, 0x00, 0xAA, 0xAA, 0xAA, 0xAA,
	0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33,
	0x00, 0x00, 0x00, 0x00, 0xAA, 0xAA, 0xAA, 0xAA,
	0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33,
	0x00, 0x00, 0x00, 0x00, 0xAA, 0xAA, 0xAA, 0xAA,
	0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33,
	0x00, 0x00, 0x00, 0x00, 0xAA, 0xAA, 0xAA, 0xAA,
	0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33,
	0x00, 0x00, 0x00, 0x00, 0xAA, 0xAA, 0xAA, 0xAA,
	0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33,
	0x00, 0x00, 0x00, 0x00, 0xAA, 0xAA, 0xAA, 0xAA,
	0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33,
	0x00, 0x00, 0x00, 0x00, 0xAA, 0xAA, 0xAA, 0xAA,
	0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33,
	0x00, 0x00, 0x00, 0x00, 0xAA, 0xAA, 0xAA, 0xAA},

	{
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF},

	{
	0xAA, 0xAA, 0xAA, 0xAA, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0xAA, 0xAA, 0xAA, 0xAA,
	0xAA, 0xAA, 0xAA, 0xAA, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0xAA, 0xAA, 0xAA, 0xAA,
	0xAA, 0xAA, 0xAA, 0xAA, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0xAA, 0xAA, 0xAA, 0xAA,
	0xAA, 0xAA, 0xAA, 0xAA, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0xAA, 0xAA, 0xAA, 0xAA,
	0xAA, 0xAA, 0xAA, 0xAA, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0xAA, 0xAA, 0xAA, 0xAA,
	0xAA, 0xAA, 0xAA, 0xAA, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0xAA, 0xAA, 0xAA, 0xAA,
	0xAA, 0xAA, 0xAA, 0xAA, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0xAA, 0xAA, 0xAA, 0xAA,
	0xAA, 0xAA, 0xAA, 0xAA, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0xAA, 0xAA, 0xAA, 0xAA},

	{
	0xFF, 0x00, 0xAA, 0x00, 0x55, 0x00, 0xAA, 0x00,
	0xFF, 0x00, 0xAA, 0x00, 0x55, 0x00, 0xAA, 0x00,
	0xFF, 0x00, 0xAA, 0x00, 0x55, 0x00, 0xAA, 0x00,
	0xFF, 0x00, 0xAA, 0x00, 0x55, 0x00, 0xAA, 0x00,
	0xFF, 0x00, 0xAA, 0x00, 0x55, 0x00, 0xAA, 0x00,
	0xFF, 0x00, 0xAA, 0x00, 0x55, 0x00, 0xAA, 0x00,
	0xFF, 0x00, 0xAA, 0x00, 0x55, 0x00, 0xAA, 0x00,
	0xFF, 0x00, 0xAA, 0x00, 0x55, 0x00, 0xAA, 0x00,
	0xFF, 0x00, 0xAA, 0x00, 0x55, 0x00, 0xAA, 0x00,
	0xFF, 0x00, 0xAA, 0x00, 0x55, 0x00, 0xAA, 0x00,
	0xFF, 0x00, 0xAA, 0x00, 0x55, 0x00, 0xAA, 0x00,
	0xFF, 0x00, 0xAA, 0x00, 0x55, 0x00, 0xAA, 0x00,
	0xFF, 0x00, 0xAA, 0x00, 0x55, 0x00, 0xAA, 0x00,
	0xFF, 0x00, 0xAA, 0x00, 0x55, 0x00, 0xAA, 0x00,
	0xFF, 0x00, 0xAA, 0x00, 0x55, 0x00, 0xAA, 0x00,
	0xFF, 0x00, 0xAA, 0x00, 0x55, 0x00, 0xAA, 0x00}
};

void drawCurrentPatternBox()
{
	int dimension;
	if(XMAX < YMAX)
		dimension = XMAX;
	else
		dimension = YMAX;

	glDisable(GL_POLYGON_STIPPLE);

	glColor3fv(colors[1]);
	glBegin(GL_POLYGON);
	glVertex2f(XMAX - 0.1 * (numberOfPatternColumns) * dimension - 2 * padding, padding);
	glVertex2f(XMAX - 0.1 * (numberOfPatternColumns) * dimension - 2 * padding, 0.1 * dimension - padding);
	glVertex2f(XMAX - 0.1 * (numberOfPatternColumns + 1) * dimension - 2 * padding, 0.1 * dimension - padding);
	glVertex2f(XMAX - 0.1 * (numberOfPatternColumns + 1) * dimension - 2 * padding, padding);
	glEnd();

	glColor3fv(colors[0]);
	glEnable(GL_POLYGON_STIPPLE);
	glPolygonStipple(patterns[currentPattern]);
	glBegin(GL_POLYGON);
	glVertex2f(XMAX - 0.1 * (numberOfPatternColumns) * dimension - 2 * padding, padding);
	glVertex2f(XMAX - 0.1 * (numberOfPatternColumns) * dimension - 2 * padding, 0.1 * dimension - padding);
	glVertex2f(XMAX - 0.1 * (numberOfPatternColumns + 1) * dimension - 2 * padding, 0.1 * dimension - padding);
	glVertex2f(XMAX - 0.1 * (numberOfPatternColumns + 1) * dimension - 2 * padding, padding);
	glEnd();
	glDisable(GL_POLYGON_STIPPLE);

	glLineWidth(3);
	glBegin(GL_LINE_LOOP);
	glVertex2f(XMAX - 0.1 * (numberOfPatternColumns) * dimension - 2 * padding, padding);
	glVertex2f(XMAX - 0.1 * (numberOfPatternColumns) * dimension - 2 * padding, 0.1 * dimension - padding);
	glVertex2f(XMAX - 0.1 * (numberOfPatternColumns + 1) * dimension - 2 * padding, 0.1 * dimension - padding);
	glVertex2f(XMAX - 0.1 * (numberOfPatternColumns + 1) * dimension - 2 * padding, padding);
	glLineWidth(1);
	glEnd();
	glLineWidth(1);

	glColor3fv(colors[clr]);
}

void drawPatternBox(int row, int offset)
{
	int dimension;
	if(XMAX < YMAX)
		dimension = XMAX;
	else
		dimension = YMAX;

	glColor3fv(colors[1]);
	glDisable(GL_POLYGON_STIPPLE);

	if(row == TOP)
	{
		glColor3fv(colors[1]);
		glBegin(GL_POLYGON);
		glVertex2f(XMAX - 0.1 * (offset) * dimension - padding, (0.1 * dimension) / 2);
		glVertex2f(XMAX - 0.1 * (offset) * dimension - padding, 0.1 * dimension - padding);
		glVertex2f(XMAX - 0.1 * (offset + 1) * dimension - padding, 0.1 * dimension - padding);
		glVertex2f(XMAX - 0.1 * (offset + 1) * dimension - padding, (0.1 * dimension) / 2);
		glEnd();

		glColor3fv(colors[0]);

		glEnable(GL_POLYGON_STIPPLE);
		glPolygonStipple(patterns[row + 2 * offset]);
		glBegin(GL_POLYGON);
		glVertex2f(XMAX - 0.1 * (offset) * dimension - padding, (0.1 * dimension) / 2);
		glVertex2f(XMAX - 0.1 * (offset) * dimension - padding, 0.1 * dimension - padding);
		glVertex2f(XMAX - 0.1 * (offset + 1) * dimension - padding, 0.1 * dimension - padding);
		glVertex2f(XMAX - 0.1 * (offset + 1) * dimension - padding, (0.1 * dimension) / 2);
		glEnd();
		glDisable(GL_POLYGON_STIPPLE);

		glLineWidth(3);
		glBegin(GL_LINE_LOOP);
		glVertex2f(XMAX - 0.1 * (offset) * dimension - padding, (0.1 * dimension) / 2);
		glVertex2f(XMAX - 0.1 * (offset) * dimension - padding, 0.1 * dimension - padding);
		glVertex2f(XMAX - 0.1 * (offset + 1) * dimension - padding, 0.1 * dimension - padding);
		glVertex2f(XMAX - 0.1 * (offset + 1) * dimension - padding, (0.1 * dimension) / 2);
		glLineWidth(1);
		glEnd();
	}
	else
	{
		glColor3fv(colors[1]);
		glBegin(GL_POLYGON);
		glVertex2f(XMAX - 0.1 * (offset) * dimension - padding, padding);
		glVertex2f(XMAX - 0.1 * (offset) * dimension - padding, (0.1 * dimension - padding) / 2);
		glVertex2f(XMAX - 0.1 * (offset + 1) * dimension - padding, (0.1 * dimension - padding) / 2);
		glVertex2f(XMAX - 0.1 * (offset + 1) * dimension - padding, padding);
		glEnd();

		glColor3fv(colors[0]);

		glEnable(GL_POLYGON_STIPPLE);
		glPolygonStipple(patterns[row + 2 * offset]);
		glBegin(GL_POLYGON);
		glVertex2f(XMAX - 0.1 * (offset) * dimension - padding, padding);
		glVertex2f(XMAX - 0.1 * (offset) * dimension - padding, (0.1 * dimension - padding) / 2);
		glVertex2f(XMAX - 0.1 * (offset + 1) * dimension - padding, (0.1 * dimension - padding) / 2);
		glVertex2f(XMAX - 0.1 * (offset + 1) * dimension - padding, padding);
		glEnd();
		glDisable(GL_POLYGON_STIPPLE);

		glLineWidth(3);
		glBegin(GL_LINE_LOOP);
		glVertex2f(XMAX - 0.1 * (offset) * dimension - padding, padding);
		glVertex2f(XMAX - 0.1 * (offset) * dimension - padding, (0.1 * dimension - padding) / 2);
		glVertex2f(XMAX - 0.1 * (offset + 1) * dimension - padding, (0.1 * dimension - padding) / 2);
		glVertex2f(XMAX - 0.1 * (offset + 1) * dimension - padding, padding);
		glLineWidth(1);
		glEnd();
	}
	glColor3fv(colors[clr]);
}

void drawPatternBar()
{
	int i;
	for(i = 0;i < numberOfPatternColumns; i++)
	{
		drawPatternBox(TOP, i);
		drawPatternBox(BOTTOM, i);
	}
	drawCurrentPatternBox();
	glFlush();
}